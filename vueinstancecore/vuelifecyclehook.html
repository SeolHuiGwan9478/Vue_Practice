<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Vue.js Sample</title>
    </head>
    <body>
        <div id="app">
            {{ a }}
        </div>
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
        <script>
            new Vue({
                el: "#app",
                data: {
                    a: 1
                },
                beforeCreate: function () {
                    console.log("beforeCreate : " + this.a);
                },
                created: function () {
                    console.log("created : " + this.a);
                },
                beforeMount: function () {
                    console.log("beforeMount : " + this.a);
                },
                mounted: function () {
                    console.log("Mounted : " + this.a);

                    this.$nextTick(function () {
                        //모든 화면이 렌더링된 후 실행한다.
                        this.a = 5;
                        console.log("Mounted $nextTick : " + this.a);
                        //this.a = 3을 하면 한번 더 beforeUpdate 와 updated를 실행한다.
                    });
                },
                beforeUpdate: function () {
                    /* 데이터가 변경되면, 가상 DOM 재 렌더링과 패치가 이뤄지기 전에 호출됩니다.
                    이 훅에서 더 많은 상태 변경을 수행할 수 있으며
                    추 가로 재 렌더링을 트리거하지 않습니다.     */

                    this.a = 5
                    console.log('beforeUpdate : ' + this.a)
                },
                updated: function () {
                    /* 데이터가 변경되어 가상 DOM이 재 렌더링되고 패치되면 호출됩니다.

                    이 훅이 호출되면 엘리먼트의 DOM이 업데이트 된 상태가 되어
                    이 훅에서 DOM 종속적인 연산을 할 수 있습니다.
                    그러나 대부분의 경우 무한루프가 발생할 수 있으므로
                    훅에서 상태를 변경하면 안됩니다.
                    상태 변화에 반응하기 위해서 계산된 속성 또는 [감시자(#watch)를 사용하는 것이 더 좋습니다.
                
                    updated는 모든 자식 컴포넌트가 재-렌더링 된 상태를 보장하지 않습니다.
                    updated 내부에서 vm.$nextTick를 사용하면 전체가 업데이트된 상태를 보장합니다.
                    */
                    console.log('Updated : ' + this.a)
                },
                beforeDestroy: function () {
                    /* Vue 인스턴스가 제거되기 전에 호출됩니다.
    이 단계에서 인스턴스는 아직 완벽하게 작동합니다. */
                    console.log('beforeDestroy : ' + this.a)
                },
                destroyed: function () {
                    /*  Vue 인스턴스가 제거된 후 호출됩니다.
     이 훅이 호출되면 Vue 인스턴스의 모든 디렉티브가 바인딩 해제 되고
     모든 이벤트 리스너가 제거되며 모든 하위 Vue 인스턴스도 삭제됩니다. */
                    console.log('destroyed : ' + this.a)
                }
            });
        </script>
    </body>
</html>